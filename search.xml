<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Sping知识点</title>
      <link href="/2022/08/26/Sping%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2022/08/26/Sping%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>Spring是一个开源的Java框架平台，为容易快速的开发出耐用的java应用程序提供了全面的技术设施</p><p><strong>Spring的优势</strong>：</p><ol><li>非侵入式设计：应用程序对框架的依赖最小化，即Spring开发应用中的对象可以不依赖于Spring的API</li><li>方便解耦、简化开发：Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护都交给Spring管理，大大降低了程序之间的耦合性</li><li>IOC:Inversion of Control的简写，控制反转，实现解耦功能，指的是将对象的创建权交给了Spring，使用Spring之前对象的创建都是由我们自己在代码中new出来的，而使用Spring之后对象的创建都交给了Spring框架，指在程序员编译后还能交由程序员控制，传统的创建方式就是new，但是new class是写在.java文件里的，编译后就成了.class字节文件，不能修改了，如果想使用抽象类和接口就非常不灵活，Spring就解决了这个问题。</li><li>依赖注入DI：对象不需要手动的调用属性set方法去设置，而是配置的方式去赋值</li><li>支持AOP：面向切面编程，通过预编译方式和允许期动态代理实现，在不修改源码的情况下，给程序动态统一添加功能的一种技术，简称AOP，是Spring框架的一个重要内容，是OOP的衍生模范，利用AOP对业务逻辑的各个部分进行隔离，降低业务逻辑的耦合性，提高程序的可重用型和开发效率。</li><li>支持声明式事务处理： 一个程序的执行单元就是执行多条sql语句的方法，</li><li>方便程序的测试：可以通过注解的方式测试Spring的程序</li><li>方便集成各种优秀框架</li><li>降低Java EE API的使用难度 对jdbc、javamail进行了封装</li></ol><h2 id="Spring模块"><a href="#Spring模块" class="headerlink" title="Spring模块"></a>Spring模块</h2><p>core:Beans,core,Context,SpEL</p><p>Web:WebSocket,Servlet,Web,Porlet</p><p>Data:JDBC,ORM,OXM,JMS,Transactions</p><p>Other:AOP,Aspects,instrument,Messageing</p><h1 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h1><h2 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h2><ol><li>IoC(控制反转)：控制反转通过依赖注入的方式，来实现对象之间松耦合关系，程序运行时依赖对象会由一些辅助对象动态生成，并注入被依赖的对象中，动态绑定两者之间的关系，负责对象的生成和依赖的注入，然后交由我们使用，简而言之，IoC就是一个定义对象的依赖关系，而不创建他们的过程，在Spring中类的实例化、依赖的实例化、依赖的传入都交由Spring的Bean的容器来控制，而不是用new的方式实例化对象，实际的控制权已经交到Sping程序管理，而不是在最初的源码，所以叫控制反转，也就是对象控制权的反转。</li><li>DI(依赖注入)：</li><li>Bean配置、加载</li></ol><p>Beanfactory使用IoC模式将应用的配置和依赖性规范与实际的应用程序代码分开，Beanfactory使用依赖注入的方式提供给组件依赖，主要实现控制反转、依赖注入、Bean配置、加载。</p><h3 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h3><p>JavaBean：1、是一个遵循特定写法的Java类，默认无参的构造函数，其中的类成员都是private(私有)的，有参数的构造器无法给成员变量赋值，而JavaBean中有get、set方法，更没有创建有参数重载的必要。2、需要被序列化、并实现了序列化的接口</p><p>SpringBean：在Spring中，构成应用程序主干，并Spirng IOC容器管理的对象称为bean，bean是一个由Spring IoC容器实例化、组装和管理的对象</p><p>SpringBean规范：1、所有属性为private      2、提供默认构造方法   3、提供getter和setter    4、实现serializable接口</p><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>Spring Context(上下文) 用来存储程序和一些初始化的信息，比如访问数据库之前要通过连接字符串来来获取数据库的操作对象，这些公共的东西就可以放在Context里</p><p>启动Spring&#x3D;&#x3D;启动AbstractApplicationContext:</p><p>Spring Context初始化从开始到结束整个过程中，都在这个方法里，创建、注册BeanFactory</p><p>ApplicationContext:‘应用的前后关系’，继承了beanFactory的接口，通过Spring提供的IoC容器，可以将对象之间的依赖关系可以由Spring进行控制，有了Spring就不必再为单实例模式、属性文件解析等一些很底层需求来写代码，可以更加注重项目需求</p><h2 id="SpEL"><a href="#SpEL" class="headerlink" title="SpEL"></a>SpEL</h2><p>全称：Sring Expression Language是一种简化开发的表达式，通过使用表达式来简化开发，减少一些逻辑、配置的编写</p><ol><li>使用bean的ID来引用bean</li><li>调用方法和访问对象的属性</li><li>正则表达式匹配</li><li>对值进行算术、关系和逻辑运算</li><li>集合操作</li></ol><h1 id="数据模块"><a href="#数据模块" class="headerlink" title="数据模块"></a>数据模块</h1><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>Spring JDBC是Spring所提供的持久层技术，他的主要目的降低JDBC API 的使用难度</p><p>三层架构：</p><ol><li>持久层：建立class实体类和数据库中数据表的映射，也叫ORM映射，数据库中的每个表都有一个对应的class文件，方便数据的操作。(比如数据库中有一个student表，有id、name、age三个字段，在java类中对应的就有一个student.java类，学生类里有id、name、age三个成员变量)</li><li>业务层：被封装的方法</li><li>表现层：前端部分，用来接收用户的请求和呈现数据，是与实际用户交互的部分</li></ol><h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><ol><li>ORM是通过使用描述对象和数据库直接映射的元数据</li><li>ORM框架采用元数据来描述对象：关系映射细节</li><li>Spring对Hibernate等进行了封装</li></ol><h2 id="OXM"><a href="#OXM" class="headerlink" title="OXM"></a>OXM</h2><p>全称object xml Mapper</p><p>目的是在Java对象和XML文档之间来回转换</p><h2 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h2><p>JMS模块包含生成和消息的信息的功能，</p><h2 id="Transactions"><a href="#Transactions" class="headerlink" title="Transactions"></a>Transactions</h2><p> 事务是用户定义的数据库操作的集合，这些操作作为一个完整的有机工作单元，要么全部正确执行，要么全部不执行。</p><p>四大特征：原子性、一致性、隔离性、持久性</p><h1 id="Web模块"><a href="#Web模块" class="headerlink" title="Web模块"></a>Web模块</h1><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>WebSocket模块为WebSocket-based提供了支持，在web引用程序中提供了客户端和服务端之间通信的方式</p><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>该模块包含Spring MVC的实现，Spring MVC框架使得模型范围内的代码和webform之间能够清晰的分离出来</p><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><p>模块提供了基本的面向web的集成功能，Web模块建立在应用程序上下文模块之上，包含Spring-WebMVC模块</p><h2 id="Prolet"><a href="#Prolet" class="headerlink" title="Prolet"></a>Prolet</h2><p>Prolet模块提供了在Prolet环境中实现MVC，并且反映了web servlet模块的功能，Spring框架通过web mvc模块提供了自己的mvc实现，Spring框架中的Prolet mvc模块则是基于web mvc模块Prolet的实现</p><h1 id="Other模块"><a href="#Other模块" class="headerlink" title="Other模块"></a>Other模块</h1><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>提供了面向切面编程的实现，允许定义方法拦截器和切入点对代码进行解耦，实现了引用分离的功能，通过配置管理特性，Spring AOP模块直接将面向方面的编程集成到了Spring框架中，所以可以很容易的使用Spring框架管理任何对象支持AOP，AOP要达到的效果是保证开发者在不修改源代码的前提下，为系统中的业务组件添加某种功能。</p><p>静态AOP：在编译阶段对程序源代码进行修改</p><p>动态AOP：在运行阶段对动态生成代理对象</p><h2 id="Aspects"><a href="#Aspects" class="headerlink" title="Aspects"></a>Aspects</h2><p>Aspects模块提供了与AspectJ的集成，这是一个功能强大且成熟的面向切面编程(AOP)框架。</p><h2 id="instrument"><a href="#instrument" class="headerlink" title="instrument"></a>instrument</h2><p>instrument是类加载器的意思，提供了类工具的支持和类加载器的实现</p><h2 id="Messaging"><a href="#Messaging" class="headerlink" title="Messaging"></a>Messaging</h2><p>spring-messaging模块为集成messaging <a href="https://so.csdn.net/so/search?q=api&spm=1001.2101.3001.7020">api</a>和消息协议提供支持。</p><h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><p>支持对具有JUnit或TestNG框架的Spring组件的测试</p><h1 id="Spring核心"><a href="#Spring核心" class="headerlink" title="Spring核心"></a>Spring核心</h1><h2 id="设计模式：工厂模式"><a href="#设计模式：工厂模式" class="headerlink" title="设计模式：工厂模式"></a>设计模式：工厂模式</h2><p>在工厂模式中，在创建对象时不会对创建者暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象，定义一个创建对象的接口，让其子类来决定实例化哪个工厂类，工厂模式会使创建过程延迟到子类来进行</p><h3 id="工厂模式优点："><a href="#工厂模式优点：" class="headerlink" title="工厂模式优点："></a>工厂模式优点：</h3><ol><li>调用者只需要知道其名称就可以</li><li>扩展性高，只要扩展一个工厂类就可以</li><li>屏蔽产品的具体实现，调用者只关心产品的接口</li></ol><h3 id="工厂模式缺点"><a href="#工厂模式缺点" class="headerlink" title="工厂模式缺点"></a>工厂模式缺点</h3><p>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中的类的个数成倍增加，增加了系统的复杂度 </p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>这种设计模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建，这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象</p><ol><li><strong>注意：</strong>     单例类只能有一个实例</li><li>单例类必须自己创建自己的唯一实例</li><li>单例类必须给所有其他对象提供这以实例</li></ol><p>懒汉式： 时间换空间，每次获取实例的时候都会进行判断，看是否需要创建实例，这样显然就浪费了每次判断的时间。线程不安全</p><p>饿汉式：空间换时间，类加载的时候已经创建好了类实例，每次调用的时候就不用去判断，节省了运行的时间，线程是安全的，执行效率很高，缺点：类加载的时候就已经实例化了，浪费了内存</p><h1 id="IoC介绍"><a href="#IoC介绍" class="headerlink" title="IoC介绍"></a>IoC介绍</h1><p>Inversion of Control 控制权的反转，控制反转是指在程序开发中，实例的创建不在由调用者管理，而是由Spring容器创建，目的是增加灵活性，降低耦合度。Spirng程序会负责控制程序之间的关系，而不是由程序代码控制，因此控制权由程序代码转移到了Spring容器中。</p><h2 id="IoC底层原理"><a href="#IoC底层原理" class="headerlink" title="IoC底层原理"></a>IoC底层原理</h2><p>XML、工厂模式、反射</p><h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>  BeanFactory是基础类型的IoC容器，他提供了完整的IoC服务支持，BeanFactroy就是一个管理bean的工厂，主要负责初始化各种bean并调用他们生命周期方法</p><p>BeanFactory接口有多个实现类,最常用XmlBeanFactroy，他是根据Xml配置文件的定义来装配bean的，创建beanFactory实例的时候需要提供Xml的据对路径地址</p><h2 id="ApplicationContent"><a href="#ApplicationContent" class="headerlink" title="ApplicationContent"></a>ApplicationContent</h2><p>Spring官方更推荐的是ApplicationContext</p><p>ApplicationContext接口有两个常用的实现类：</p><p>ClassPathXmlApplicationContext,：从系统中的类路径去找xml来实现ApplicationContext</p><p>FileSystemXmlApplicationContext：从文件系统中去找xml来实现ApplicationContext</p><h1 id="Bean-1"><a href="#Bean-1" class="headerlink" title="Bean"></a>Bean</h1><p>Bean的对象是构成Spring程序的支柱，也是由Spring IoC容器管理的，在Spring中，构成应用程序主干，并由Spring IoC管理的对象，称之为Bean，Bean是由Spring IoC容器实例化、组装和管理的对象</p><h2 id="Bean配置"><a href="#Bean配置" class="headerlink" title="Bean配置"></a>Bean配置</h2><p>基于注解的配置</p><p>基于Java的配置</p><p>基于XML的配置文件(常用)</p><h2 id="Bean属性"><a href="#Bean属性" class="headerlink" title="Bean属性"></a>Bean属性</h2><p>class：用来创建bean的bean类</p><p>name：这个属性指定唯一的bean标识符</p><p>scope：是定义Bean的作用域</p><p>List、Map、Set：是分别注入各自类型集合的</p><p>value：bean里的字段赋值</p><p>constructor-arg：通过构造函数注入</p><p>property：通过setter对应的方法注入</p><p>factory-bean：是生成bean的工厂对象</p><p>lazy-initialzation mode :延迟初始化的bean</p><p>initialization:回调方法(在bean的所有必须的属性被容器设置之后)</p><p>destruction:回调方法 (当包含该bean的容器被销毁时)</p><h2 id="Bean的实例化"><a href="#Bean的实例化" class="headerlink" title="Bean的实例化"></a>Bean的实例化</h2><ol><li>构造器实例化</li><li>静态工厂方法实例化</li><li>实例工厂方法实例化</li><li>实现FactoryBean接口实例化</li></ol><h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><p>当一个Spring定义一个bean时必须声明这个bean的作用域</p><ol><li>singleton(单例模式)：确保Spring容器中只会存在一个共享的Bean实例</li><li>prototype(原型模式)：每次请求bean或者将其注入到另一个bean时都会创建一个新的实例</li><li>request(每次HTTP、每次Bean实例)：每次有http请求时，都会创建新的实例</li><li>session(每次会话、每次Bean实例)：同一个Http Session(会话)之间共享一个bean，而不同的会话使用不同的bean</li><li>global Session(全局的Session)</li></ol><h2 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期"></a>Bean生命周期</h2><p>当一个Bean被加载到Spring容器时，他就具有了生命</p><p>生命周期：实例化、属性赋值、初始化、销毁 </p><h2 id="Bean继承"><a href="#Bean继承" class="headerlink" title="Bean继承"></a>Bean继承</h2><p>Spring Bean定义的继承与Java类的继承无关，但是继承的概念是一样的</p><h2 id="Bean自动装配"><a href="#Bean自动装配" class="headerlink" title="Bean自动装配"></a>Bean自动装配</h2><p>手动装配：要自己定义属性然后赋值</p><p>自动装配：Spring IoC容器可以进行自动装配Bean，需要在@Autowired属性定义自动装配模式</p><p>自动装配模式：</p><p>byType(根据类型自动装配)</p><p>byName（根据名称自动装配）</p><p>constructor(通过构造器自动装配)</p><h2 id="Bean事件处理"><a href="#Bean事件处理" class="headerlink" title="Bean事件处理"></a>Bean事件处理</h2><p>你已经看见了所有的Spring核心都是ApplicationContext负责bean的完整生命周期，当加载Bean时ApplicationContext发布某些类型的事件</p><ol><li>ContextRefreshEvent</li><li>ContextStartedEvent</li><li>ContextStoppedEvent</li><li>ContextClosedEvent</li><li>RequestHandledEvent</li></ol><h2 id="Bean后置处理器"><a href="#Bean后置处理器" class="headerlink" title="Bean后置处理器"></a>Bean后置处理器</h2><p>BeanPostProcessor接口定义回调方法，你可以实现该方法来提供自己的实例化的逻辑，可以插入一个或多个自定义BeanPostProcessor实现来完成实例化，配置和初始化一个Bean之后来实现自己自定义的回调方法</p><h2 id="Bean注解配置"><a href="#Bean注解配置" class="headerlink" title="Bean注解配置"></a>Bean注解配置</h2><p>@Required：用于Bean的setter方法，表明受影响的Bean在配置中，必须放在xml文件中，否则就会抛出异常，5.0以后弃用了</p><p>@Autoired：可以用在bean的setter方法，非setter方法，和构造函数</p><h1 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h1><p>依赖注入和控制反转含义相同，他们是从两个角度描述的同一个概念，</p><p><strong>控制反转</strong>：由Spring容器来创建，Spring容器会负责控制程序之间的关系，这样控制权便由应用代码转移到Spring容器，控制权发生了反转</p><p><strong>依赖注入</strong>：Spring容器负责将被依赖对象赋值给调用者的成员变量，这就相当于为调用者注入了它依赖的实例</p><h2 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h2><p>指IoC容器使用setter方法注入被依赖的实例，通过调用无参构造器、或无参static工厂方法，实例化bean后，调用bean的setter方法，即可实现基于setter的DI</p><h1 id="JDBC-1"><a href="#JDBC-1" class="headerlink" title="JDBC"></a>JDBC</h1><p>Spring JDBC是基于普通的JDBC的 ，(如果自己从头开始写JDBC会出现很多考虑不到和处理不好的细节，比如根据链接字符串获取数据库的对象还有准备和执行sql语句、处理异常、处理事务对象的回收、与创建，到最后关闭连接，轻则影响程序的性能，重则导致程序崩溃)</p><p>Jdbc Template是Spring框架中提供的一个对象，是对原始jdbc API对象简单的封装，Spring框架为我们提供了很多操作模板类，比如操作关系型数据库Jdbc Template，Jdbc Template类是线程安全配置，所以可以配置Jdbc单个实例，然后将共享的引用安全的注入到多个dao中，使用Jdbc Template类的时候常见做法：可以在Spring配置文件中配置数据源，然后共享数据源的bean依赖注入到dao类，并且在数据源的设值函数中创建了Jdbc Template</p><p>DTO(Data Transfer Object):定义的是实体类.class文件，该文件包含实体类的属性对应的get、set 方法，一般的命名时user.DTO</p><p>DAO(Data Access Object):会调用DTO层，DAO层中定义的实际使用方法(增删改查),一般命名userMapper</p><h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><p>jdbc.query():SQL-SELECT</p><p>jdbc.update():SQL_UPDATE、SQL_INSERT</p><p>jdbc.execute() : SQL_ALTER</p><h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><p>Maven是一个项目管理和构建自动化工具</p><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><p>传统的Spring项目框架搭建需要大量的配置， 而且项目的开发、测试 都需要依赖服务器，开比较耗时，而且容易出错，SpringBoot由第三方团队提供的全新框架，是为了让程序员更好、更方便的使用Spring，把繁琐的Spring配置进行了简化，由于Springboot自带服务器，所以项目可以直接以jar的形式去运行，方便了开发、测试、部署的环节，搭建SpringBoot框架不需要对Spirng进行过多的配置，就可以运行</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>搭建项目快</li><li>让测试变的简单内置的Junit、SpringBoot test等多种测试框架</li><li>Spring Boot让配置变得简单</li><li>内嵌容器 省去了配置tomcat的时间</li><li>方便监控 SpringBoot有 actuator组件提供了应用程序的系统监控 可以查看应用系统的详细信息</li></ol> <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"> <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"></property> <property name="url" value="jdbc:mysql://localhost:3306/stu_db?serverTimeZone=UTC&amp;useSSL=false"></property> <property name="username" value="root"></property> <property name="password" value="wzx"></property> </bean><bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"> <property name="dataSource" ref="dataSource"></property></bean>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList</title>
      <link href="/2022/08/08/ArrayList%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>/2022/08/08/ArrayList%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayList底层原理"><a href="#ArrayList底层原理" class="headerlink" title="ArrayList底层原理"></a>ArrayList底层原理</h1><h3 id="ArrayList-了解过吗？它是啥？有啥用"><a href="#ArrayList-了解过吗？它是啥？有啥用" class="headerlink" title="ArrayList 了解过吗？它是啥？有啥用?"></a>ArrayList 了解过吗？它是啥？有啥用?</h3><p>众所周知，Java 集合框架拥有两大接口 <code>Collection</code> 和 <code>Map</code>，其中，<code>Collection</code> 麾下三生子 <code>List</code>、<code>Set</code> 和 <code>Queue</code>。<code>ArrayList</code> 就实现了 <code>List</code> 接口，其实就是一个数组列表，不过作为 Java 的集合框架，它只能存储对象引用类型，也就是说当我们需要装载的数据是诸如 <code>int</code>、<code>float</code> 等基本数据类型的时候，必须把它们转换成对应的包装类。</p><p><code>ArrayList</code> 的底层实现是一个 <code>Object</code> 数组：</p><p><img src="/2022/08/08/ArrayList%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/20210318002618.png" alt="img"></p><p>既然它是基于数组实现的，数组在内存空间中是连续分配的，那必然查询速率非常快，不过当然也肯定逃不过增删效率低的缺陷。</p><p>另外，和 <code>ArrayList</code> 一样同样实现了 <code>List</code> 接口的、我们比较常用的还有 <code>LinkedList</code>。<code>LinkedList</code> 比较特殊，它不仅实现了 <code>List</code> 接口，还实现了 <code>Queue</code> 接口，所以你可以看见 <code>LinkedList</code> 经常被当作队列使用：</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue = ``new` `LinkedList&lt;&gt;();</span><br></pre></td></tr></table></figure><p><code>LinkedList</code> 人如其名，它的底层自然是基于<a href>链表</a>的，而且还是个双向<a href>链表</a>。<a href>链表</a>的特性和数组正好是反的，由于没有索引，所以查询效率低，但是增删速度快。</p><p><img src="/2022/08/08/ArrayList%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/20210318003923.png" alt="img"></p><h3 id="2-ArrayList-如何指定底层数组大小的？"><a href="#2-ArrayList-如何指定底层数组大小的？" class="headerlink" title="2. ArrayList 如何指定底层数组大小的？"></a>2. ArrayList 如何指定底层数组大小的？</h3><p>OK，首先，既然咱真正存储数据的地方是数组，那我们初始化 <code>ArrayList</code> 的时候自然要给数组分配一个大小，开辟一个内存空间。我们先来看看 <code>ArrayList</code> 的无参构造函数：</p><p><img src="/2022/08/08/ArrayList%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/20210318005234.png" alt="img"></p><p>可以看到，它为底层的 <code>Object</code> 数组也就是 elementData 赋值了一个默认的空数组 <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>。也就是说，使用无参构造函数初始化 <code>ArrayList</code> 后，它当时的数组容量为 0 。</p><p>这给咱初始化一个容量为 0 的数组有啥用？啥也存不了啊？别急，如果使用了无参构造函数来初始化 <code>ArrayList</code>， 只有当我们真正对数据进行添加操作 <code>add</code> 时，才会给数组分配一个默认的初始容量 <code>DEFAULT_CAPACITY = 10</code>。看下图：</p><p><img src="/2022/08/08/ArrayList%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/20210318010150.png" alt="img"></p><p>说完了无参构造，<code>ArrayList</code> 的有参构造函数就是中规中矩了，按照用户传入的大小开辟数组空间：</p><p><img src="/2022/08/08/ArrayList%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/20210318010554.png" alt="img"></p><h3 id="3-数组的大小一旦被规定就无法改变，那-ArrayList-是怎么对底层数组进行扩容的？"><a href="#3-数组的大小一旦被规定就无法改变，那-ArrayList-是怎么对底层数组进行扩容的？" class="headerlink" title="3. 数组的大小一旦被规定就无法改变，那 ArrayList 是怎么对底层数组进行扩容的？"></a>3. 数组的大小一旦被规定就无法改变，那 ArrayList 是怎么对底层数组进行扩容的？</h3><p><code>ArrayList</code> 的底层实现是 <code>Object</code> 数组，我们知道，数组的大小一旦被规定就无法改变。那如果我们不断的往里面添加数据的话，<code>ArrayList</code> 是如何进行扩容的呢？或者说 ArrayList 是如何实现存放任意数量对象的呢？</p><p>OK，扩容发生在啥时候？那肯定是我们往数组中新加入一个元素但是发现数组满了的时候。没错，我们去 <code>add</code> 方法中看看 <code>ArrayList</code> 是怎么做扩容的：</p><p><img src="/2022/08/08/ArrayList%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/20210318012036.png" alt="img"></p><p><code>ensureExplicitCapacity</code> 判断是否需要进行扩容，很显然，<code>grow</code> 方法是扩容的关键：</p><p><img src="/2022/08/08/ArrayList%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/20210318012249.png" alt="img"></p><p>说实话，别的都不用看了，看上面图中的黄色框框就知道 <code>ArrayList</code> 是怎么扩容的了：扩容后的数组长度 &#x3D; 当前数组长度 + 当前数组长度 &#x2F; 2。最后使用 <code>Arrays.copyOf</code> 方法直接把原数组中的数组 copy 过来，需要注意的是，<code>Arrays.copyOf</code> 方<em><strong>创建一个</strong>新数组</em>*然后再进行拷贝。</p><p>举个例子画个图来演示一下：</p><p><img src="/2022/08/08/ArrayList%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/20210318200357.png" alt="img"></p><h3 id="4-既然扩容发生在添加数据的时候，讲讲-ArrayList-具体是怎么添加数据的"><a href="#4-既然扩容发生在添加数据的时候，讲讲-ArrayList-具体是怎么添加数据的" class="headerlink" title="4. 既然扩容发生在添加数据的时候，讲讲 ArrayList 具体是怎么添加数据的"></a>4. 既然扩容发生在添加数据的时候，讲讲 ArrayList 具体是怎么添加数据的</h3><p>OK，<code>add</code> 方法我们刚刚讲了一半，添加数据前会先判断一下是否需要扩容，真正的添加数据的操作在下半部分：</p><p><img src="/2022/08/08/ArrayList%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/20210318201926.png" alt="img"></p><p>先讲下 <code>add(int index, E element)</code> 这个方法的含义，就是在指定索引 index 处插入元素 element。比如说 <code>ArrayList.add(0, 3)</code>，意思就是在头部插入元素 3。</p><p>再来看看 <code>add</code> 方法的核心 <code>System.arraycopy</code>，这个方法有 5 个参数：</p><ul><li>elementData：源数组 </li><li>index：从源数组中的哪个位置开始复制 </li><li>elementData：目标数组 </li><li>index + 1：复制到目标数组中的哪个位置 </li><li>size - index：要复制的源数组中数组元素的数量</li></ul><p>解释一下上面代码中 <code>arraycopy</code> 的意思，举个例子，我们想要在 index &#x3D; 5 的位置插入元素，首先，我们会复制一遍源数组 elementData（这里我们称复制的数组为新数组吧），然后把源数组中从 index &#x3D; 5 的位置开始到数组末尾的元素，放到新数组的 index + 1 &#x3D; 6 的位置上：</p><p><img src="/2022/08/08/ArrayList%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/20210318203028.png" alt="img"></p><p>于是，这就给我们要新增的元素腾出了位置，然后在新数组 index &#x3D; 5 的位置放入元素 element 就完成了添加的操作：</p><p><img src="/2022/08/08/ArrayList%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/20210318203638.png" alt="img"></p><p>显然，不用多说，ArrayList 的将数据插入到指定位置的操作性能非常低下，因为要开辟新数组复制元素啊，要是涉及到扩容那就更慢了。</p><p>另外，<code>ArrayList</code> 还内置了一个直接在末尾添加元素的 <code>add</code> 方法，不用复制数组，直接 size ++ 就好，这个方法应该是我们最常使用的：</p><p><img src="/2022/08/08/ArrayList%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/20210318211214.png" alt="img"></p><h3 id="5-ArrayList-又是如何删除数据的呢？"><a href="#5-ArrayList-又是如何删除数据的呢？" class="headerlink" title="5. ArrayList 又是如何删除数据的呢？"></a>5. ArrayList 又是如何删除数据的呢？</h3><p>Ctrl + F 找到 <code>remove</code> 方法，就这？和添加一个道理，也是复制数组</p><p><img src="/2022/08/08/ArrayList%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/20210318203837.png" alt="img"></p><p>举个例子，假设我们要删除数组的 index &#x3D; 5 的元素，首先，我们会复制一遍源数组，然后把源数组中从 index + 1 &#x3D; 6 的位置开始到数组末尾的元素，放到新数组的 index &#x3D; 5 的位置上：</p><p><img src="/2022/08/08/ArrayList%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/20210318204239.png" alt="img"></p><p>也就是说 index &#x3D; 5 的元素直接被覆盖掉了，给了你被删除的感觉。同样的，它的效率自然也是十分低下的</p><h3 id="6-ArrayList-是线程安全的吗？不安全的表现"><a href="#6-ArrayList-是线程安全的吗？不安全的表现" class="headerlink" title="6. ArrayList 是线程安全的吗？不安全的表现"></a>6. ArrayList 是线程安全的吗？不安全的表现</h3><p><code>ArrayList</code> 和 <code>LinkedList</code> 都不是线程安全的，我们以在末尾添加元素的 <code>add</code> 方法为例，来看看 <code>ArrayList</code> 线程不安全的表现是啥：</p><p><img src="/2022/08/08/ArrayList%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/20210318211130.png" alt="img"></p><p>黄色框里的并不是一个原子操作，它由两步操作构成：</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elementData[size] = e;``size = size + ``1``;</span><br></pre></td></tr></table></figure><p>在单线程执行这两条代码时，那当然没有任何问题，但是当多线程环境下执行时，可能就会发生<strong>一个线程添加的值覆盖另一个线程添加的值</strong>。举个例子：</p><ul><li>假设 size &#x3D; 0，我们要往这个数组的末尾添加元素 </li><li>线程 A 开始添加一个元素，值为 A。此时它执行第一条操作，将 A 放在了数组 elementData 下标为 0 的位置上 </li><li>接着线程 B 刚好也要开始添加一个值为 B 的元素，且走到了第一步操作。此时线程 B 获取到的 size 值依然为 0，于是它将 B 也放在了 elementData 下标为 0 的位置上 </li><li>线程 A 开始增加 size 的值，size &#x3D; 1 </li><li>线程 B 开始增加 size 的值，size &#x3D; 2</li></ul><p>这样，线程 A、B 都执行完毕后，理想的情况应该是 size &#x3D; 2，elementData[0] &#x3D; A，elementData[1] &#x3D; B。而实际情况变成了 size &#x3D; 2，elementData[0] &#x3D; B（线程 B 覆盖了线程 A 的操作），下标 1 的位置上什么都没有。并且后续除非我们使用 set 方法修改下标为 1 的值，否则这个位置上将一直为 null，因为在末尾添加元素时将会从 size &#x3D; 2 的位置上开始。</p><p>上段代码验证下：</p><p><img src="/2022/08/08/ArrayList%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/20210318212403.png" alt="img"></p><p>结果和我们分析的一样：</p><p><img src="/2022/08/08/ArrayList%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/20210318212523.png" alt="img"></p><p><code>ArrayList</code> 的线程安全版本是 <code>Vector</code>，它的实现很简单，就是把所有的方法统统加上 <code>synchronized</code>：</p><p><img src="/2022/08/08/ArrayList%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/20210318212652.png" alt="img"></p><p>既然它需要额外的开销来维持同步锁，所以理论上来说它要比 <code>ArrayList</code> 要慢。</p><h3 id="7-为什么线程不安全还要用它呢？"><a href="#7-为什么线程不安全还要用它呢？" class="headerlink" title="7. 为什么线程不安全还要用它呢？"></a>7. 为什么线程不安全还要用它呢？</h3><p>因为在大多数场景中，查询的情况居多，不会涉及太频繁的增删。那如果真的涉及频繁的增删，可以使用<code>LinkedList</code>，底层<a href>链表</a>实现，为增删而生。而如果你非得保证线程安全那就使用 <code>Vector</code>。当然实际开发中使用最多的还是 <code>ArrayList</code>，虽然线程不安全、增删效率低，但是查询效率高啊。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ArrayList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>发布博客</title>
      <link href="/2022/08/08/java%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2022/08/08/java%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-deployer-git</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &quot;新建博客文章名字&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><ul><li>如果出现了 error： span failed</li></ul><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol><li><p>删除.deploy_git文件夹</p></li><li><p>输入git config  - - global core.autocrlf false</p></li><li><p>然后，依次执行：</p><p>hexo clean</p><p>hexo g</p><p>hexo d</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
